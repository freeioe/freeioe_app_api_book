
---

# 注意事项

应用开发中应规避的一些事项。

### 避免死循环

此避免死循环并不是说不能使用死循环，而是指避免没有调用sys:sleep的死循环。由于Lua本身的协程特性，如果在某一协程内进入了死循环，会导致其它协程进入永久的等待。所以在应用开发中，应注意避免此种情况发生。

请尽量在任何循环中增加sys:sleep(0)，来提高其他协程的唤醒率，也会缩短FreeIOE对平台指令的响应时长。

### 尽量使用无阻塞C模块接口

当应用使用C模块时，请使用模块的无阻塞方式。否则也会导致应用其他协程无法被唤醒，甚至会影响整个FreeIOE程序失去响应。

### 避免无限制的内存使用

虽然FreeIOE应用尝试限制了应用的内存使用大小，但是这并不是万能的。所以开发者应当注意应用的内存使用，避免内存的浪费。 同时也请尽量避免出现频繁的内存分配和释放，由于Lua内存回收机制，此种情况在小内存的机型上运行时，会导致运行不稳定。

### 模块命名尽量增加唯一前缀

FreeIOE隔离应用之间模块名称，但是FreeIOE系统仍然有一些内置模块，如果无限制的使用模块名称，则会导致应用（底层）在尝试调用系统模块时会错误的使用自定义模块。

### 限制使用sys:fork 和 sys:timeout的数量

这两个接口从底层上讲都是开辟了新的协程，如无限制的开辟携程，有可能导致FreeIOE系统变得缓慢而不可靠。

### 限制使用os.time

如需要获取时间，请尽量使用sys:time()，而不是os.time。 此函数会调用c库的time函数来获取时间，在大多数平台上，这个调用会使Linux从用户层切换到内核层。也就是说频繁调用这个接口会浪费大量的CPU时间片。 而sys:time()内部其实是一个周期更新的时间戳，不会进入内核层面，也就提高CPU的使用。

### 限制使用os.execute

如无比要请勿使用这个函数，因为次函数是阻塞函数。当执行一些耗时较长的shell指令，会导致FreeIOE系统陷入无响应状态

### 文件读写注意大小

如去读取较大的文件，请在每次读取和处理时注意内存使用。应当知悉read('*a')会将文件一次性读取到内存内，避免使用这种方式来读取较大的文件。请见谅使用read(max_read_number)来进行文件读取

### 注意字符编码

FreeIOE系统内的字符串都是UTF-8编码的，如有其他编码的字符串，请尽可能的进行转码后进行操作和传输。非utf-8编码字符串，有潜在的序列化和传输的风险。
